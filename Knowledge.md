# C 语言知识点总结

## 数据

- 基本类型
  - 整型家族(signed、unsigned)
    - 整型(4 个字节)
      - 有符号范围：-$2^{32}$~$2^{32}$-1
      - 无符号范围:0~$2^{32}$-1
      - 整形提升：有符号数补齐符号位、无符号数补 0
    - 长整型(>=4 个字节)
      - 有符号范围：-$2^{32}$~$2^{32}$-1
      - 无符号范围:0~$2^{32}$-1
    - 短整型(2 个字节)
      - 有符号范围：-32768-32767
      - 无符号范围：0~$2^{15}$-1
    - 双长整型(8 个字节)
      - 有符号范围：-$2^{63}$~$2^{63}$-1
      - 无符号范围:0~$2^{63}$-1
    - 字符型(1 个字节)
      - 有符号范围：-128-127
      - 无符号范围：0-255
    - 布尔型(bool)
  - 浮点类型
    - 注意点
      - 需要注意在内存中存储方式不同
      - 需要注意精度丢失问题
      - 浮点数判零、设置进度范围
      - 浮点数不能进行位运算
    - 单精度浮点型(4 个字节 6 位有效数字)数值范围：0 以及$1.2*10^{-38}$~$3.4*10^{38}$
    - 双精度浮点型(8 个字节 15 位有效数字)数值范围：0 以及$2.3*10^{-308}$~$1.7*10^{308}$
    - 长双精度型(8 个字节 15 位有效数字)数值范围：0 以及$2.3*10^{-308}$~$1.7*10^{308}$
    - 复数浮点型
- 枚举类型(enum)
  - 枚举类型取值：枚举{}中内容为枚举类型可能取值，默认从 0 开始，一次递增 1，也可以在定义时自行赋值
  - 枚举的优点
    - 增加代码可读性和可维护性
    - 和 define 定义的标识符相比，枚举有类型检查更加严谨
    - 防止了命名污染(封装)
    - 便于调试，define 不便于调试，调试时是已替换的内容
    - 使用方便，一次可以定义多个常量
- 空类型(void)
- 派生类型
  - 指针类型：`char*`、`int*`、`void*`……
  - 数组类型：`int arr[]`
  - 结构体变量类型(结构体传参传地址更好)
    - 结构体成员：可以是标量、数组、指针、其他结构体，通过点操作符(.)访问
    - 结构体内存对齐：
      - 第一个成员在结构体偏移量为 0 的位置
      - 其他成员需要对齐到自身对齐数的整数倍地址处。对齐数=编译器默认值与该成员大小的较小值
      - 结构体总大小为所有成员最大对齐数的整数倍
      - 如果嵌套结构体，嵌套结构体对齐到自己最大对齐数整数倍处，结构体整体大小是所有最大对齐数的整数倍
    - 结构体内存对齐原因
      - 平台原因(移植原因)
      - 性能原因：对齐的内存访问仅需一次
    - 位段
      - 位段的成员必须是整型、无符号整型(`unsigned int` 或 `unsigned`)、有符号整型(`int` 或 `signed`)、字符型
      - 位段的空间按照 4 字节(int)或 1 字节(char)开辟
      - 位段不跨平台、可移植程序应避免位段的使用
      - 位段从左向右或从右向左分配标准未定义
      - 两个位段，第二个无法容纳于第一个剩余的位段，剩余位段舍弃还是利用不确定
      - 位段最大数目不确定(16 位机器最大 16，32 位机器最大 32)
  - 联合(共用体)类型
    - 成员共用同一块空间
    - 联合的大小至少是最大成员的大小
    - 当最大成员大小不是最大对齐数整数倍时，要对其到对齐数的整数倍
    - 可用于判断大小端、表示点分十进制
  - 函数类型：`void fun()`

## 符号注意优先级问题

- 算术运算符：( `+` `-` `*` `/` `%` `++` `--` )
- 关系运算符：( `>` `<` `==` `>=` `<=` `!=` )
- 逻辑运算符：( `!` `&&` `||` )
- 赋值运算符：( `=` `+=` `-=` `*=` `/=` `%=` )
- 位运算符：( 按位与`&` 按位或`|` 按位异或`^` 按位取反`~` 左移`<<` 右移`>>`)
- 条件运算符：( ? : )三目运算符
- 逗号运算符( `,` )操作数从左向右依次执行，最终结果为逗号右边的值
- 指针运算符( `*` `&` )不能对空指针进行解引用++、--操作
- 强制类型转换运算符((类型))
- 成员类型操作符( `.` `->` )用于结构体成员

## 32 个关键字

- 数据类型关键字
  - char 声明字符变量
  - double 声明双精度变量
  - float 声明浮点型变量
  - int 声明整型变量
  - short 声明短整型变量
  - long 声明长整型变量
  - unsigned 声明无符号类型变量
  - signed 声明有符号类型变量
  - struct 声明结构体变量
  - union 声明共用体或联合数据类型
  - void 声明函数无返回值或无参数，声明无类型指针
  - enum 声明枚举类型
- 控制语句关键字
  - 循环语句类型关键字
    - for 遍历循环
    - do 其后紧跟循环体
    - while 条件循环或者死循环
    - break 跳出当前循环
    - continue 终止本次循环，开始下次循环
  - 条件语句类型关键字
    - if 条件语句
    - else 条件语句否定分支
    - goto 无条件跳转语句
  - 开关语句类型关键字
    - switch 用于多条件判断语句
      - switch、case 组合语句可以看作为 if、else 语句的加强版。后者适用于二分支或嵌套较少的分支，前者则在面对多分支情况时有更高的效率。
    - case 多条件判断语句分支
      - case 语句需要注意的点很多，如：为了避免多个分支重叠，需要在 case 结尾加上 break; 不要忘了 default 语句；case 语句的排序问题等。
    - default 开关语句的其他分支
  - 返回语句类型关键字
    - return 函数返回语句
      - return 用于终止一个函数，并返回其后面跟着的值。
  - 存储类型关键字
    - auto 声明自动变量
      - **auto**关键字声明自动变量，由编译器自动分配及释放。这种变量在程序执行时被快速建立，程序退出后被自动撤销，在缺省的情况下，编译器默认所有变量都是 auto 的。
    - extern 声明变量在其他文件定义
      - **extern**关键字置于变量或函数前，表明变量或函数的定义在其它文件中。链接器在遇到此类变量时会在其它模块中解析/捆绑此标识符。
    - register 声明寄存器变量
      - register 关键字请求编译器尽可能地将变量存储在 cpu 的内部寄存器中，而不是通过通过内存寻址来访问变量，这有效地提高了效率。理解这个关键字需要弄那个明白 cpu、寄存器与内存之间的关系，cpu 是不直接和内存打交道的，cpu 与内存之间的数据传输需要经过寄存器，故而将变量存储在寄存器可以提高运行效率。
    - static 声明静态变量
      - static 为声明静态变量，主要有修饰变量和修饰函数的作用。
        - 修饰变量时：变量又分为局部变量与全局变量，当变量被修饰为静态全局变量时，它的作用域为定义之处开始，到文件结尾处结束，其它文件用 extern 声明也没办法使用它；当变量在函数体内被 static 修饰，则该变量只能在这个函数里使用，即使是同一个文件也不行，称为静态局部变量。静态变量总是存储在内存静态区，即使是程序执行完毕它的值也不会被销毁。
        - 修饰函数时：在函数前面加 static 可以使函数变为静态函数，静态函数的作用域仅局限于本文件，这样可以避免其它文件中定义的函数重名。
- 其他关键字
  - const 声明只读变量
    - **const**修饰只读变量，变量一旦赋初值就不能被修改。编译器不为只读变量分配内存，这使得它的效率也很高
  - sizeof 计算数据类型长度(字节数)
    - **sizeof**后面常跟这一对括号，但它绝对不是函数，它可以计算数据类型的大小，单位为字节
  - typeof 给数据类型取别名
    - **typedef**的意思是给一个已经存在的数据类型取一个别名，而不是定义新的数据类型。尤其是结构体之类的自定义数据类型，常常需要取一个适用于实际情况的别名
  - volatile 所修饰的对象不能被编译器优化
- 表格汇总

  | 关键字 | 关键字 | 关键字 | 关键字 | 关键字 | 关键字 | 关键字 | 关键字 |
  | :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: |
  | auto | break | case | char | const | continue | default | do |
  | double | else | enum | extern | float | for | goto | if |
  | int | long | register | return | short | signed | sizeof | static |
  | struct | switch | typedef | union | unsigned | void | volatile | while |

## 语句

- 分支语句
  - if 语句
    - else 与之最近邻的 if 相匹配
  - switch 语句
    - 每一个 case 后的 break 语句不可省，最后一个分支 default 语句不能省
    - 每一个 case 具有一个唯一值
    - switch(整型表达式){case:整型常量表达式...}
  - goto 语句
    - 在需要跳转的语句前加标签，执行时 goto:标签
    - 危险的语句，尽量避免使用
- 循环语句
  - for 循环语句：注意边界问题，控制变量尽量采用“半开半闭区间”，不可再循环体内部修改变量
  - while 循环语句：嵌套循环，只跳出内层循环
  - do while 循环语句：与 while 语句相同但会比 while 语句多执行一次

## 数组

- 一维数组：数组名表示数组首元素地址，当数组名作为 sizeof 或&的操作数时，数组名表示整个数组
- 二维数组：相当于一维数组，区别在于其第一维元素其实是一个数组，数组名表示整个数组，但数组名作为 sizeof 或&的操作数时，数组名表示数组的第一行
- 指针数组：`int *arr[]`(整型指针数组) `char *arr[]`(字符型指针数组)
- 函数指针数组：`int(*p[5])(int,int)` p 先和[]结合，数组内容是`int(*)(int,int)`的函数指针
- 柔性数组
  - 特点
    - 结构体中柔性数组成员前必须至少一个其他成员
    - sizeof 返回这种结构的大小不包括柔性数组的内存
    - 包含柔性数组的结构用 mallorc()函数分配内存时，分配内存应大于结构大小
  - 优点
    - 方便释放内存
    - 减少内存碎片，提高访问速度

## 指针

- 一级指针：指向一个地址解引用得到存在该地址内的值
- 二级指针：二级指针`char**p`，解引用为一级指针`*(char**)pp=p`
- 指针的运算：`++`优先级高于`*`；指针减指针等于指针间元素个数(两指针在同一空间)指针加减整数跳过相应指针类型的大小*这个数
- 数组指针：`int[*p](10)`; `p` 先和 `*`结合，说明 `p` 是指针变量，指向一个大小为 10 个整型的数组；([]优先级高于*)
- 函数指针：`void(*pfun)()`;指针 pfun 指向函数，函数无参数，返回类型为 `void`
- 函数指针数组的指针：`void(*(*ppfunArr)[10])(const char*)`,指向一个数组的指针，数组的元素是函数指针
- 回调函数：一个通过函数指针调用的函数，如果你把函数指针(地址)作为参数传给另一个函数，当这个指针被用来调用其所指向的函数时，我们称这就是回调函数。eg:使用回调函数实现快速排序

## 函数

- 函数的定义和声明
  - 声明：函数使用一般先在头文件中声明再使用，声明是告诉编译器有一个函数叫什么、返回类型、参数是什么；
  - 定义：定义是函数的具体实现，交代函数的功能实现
- 函数的参数
  - 实参：真实传给函数的参数叫实参
  - 形参：形参在函数调用时才实例化(分配空间)，调用完成后自动销毁；形参是实参的一份临时拷贝
- 库函数、自定义函数
  - 库函数：<>为引用库函数，从标准路径搜索
  - 自定义函数：“”为引用自定义函数，从用户自定义路径搜素
- 函数的链接属性
  - 外部链接属性：一个标识符不仅可以在当前源文件使用，使用 extern 的声明可在其他源文件内使用，全局变量都具有外部链接属性
  - 内部链接属性：具有外部链接属性的标识符前加 static 就会变为内部链接属性
- 无属性：局部变量是无属性的
- 函数的栈顺：详见 CSDN 博客
- 函数递归：把一个大型复杂问题层层转化为一个与原问题相似的规模较小的问题来求解(1.存在限制条件 2 每次递归越来越接近该限制条件)
- main 函数参数解析：argc 命令行参数个数、argv[]存放指向命令行参数的指针数组，最后一个元素为 NULL、envp 存放指向环境变量的字符指针数组
- 可变参数列表：va_Iist(访问参数列表未确定部分)、va_arg(初始化)、va_end 1.可变参数列表必须从头到尾逐个访问 2.可变参数列表中至少有一个命名参数 3.这些宏无法直接判断实际存在参数数量、类型
- 字符串函数
  - strcpy、strcat、strcmp、strlen、strstr、strchr、mecpy、memmove 的模拟实现

## 输入输出函数

- 错误报告函数 void perror(const char \*s)用于提示错误的准确原因
- 终止执行:void exit(int status)0 正常退出，非 0 异常退出
- I/O 函数库
  - 流
    - 文本流
    - 二进制流
  - 输入、输出函数
    - getchar()、putchar()
    - fgetc()、getc()、fputc()、putc()
    - fgets()、gets()、fputs()、puts()
    - scanf()、fscanf()、printf()、fprintf()、fread()、fwrite()

## 预处理

- 预定义符号
  - `__LINE__`：当前行号
  - `__FILE__`：当前文件名
  - `__DATE__`：当前日期
  - `__TIME__`：当前时间
  - `__STDC__`：是否是 C89/90 标准
  - #error、#pragma...
- define 定义的标识符：全部大写，最后不加分号，避免替换后悬空其他语句
- 宏定义、宏替换：宏的名字大写，宏不能出现递归，宏的参数内部不计算，预处理阶段仅为替换(注意不要吝啬括号)
- 宏和函数的对比 1.代码长度，宏多次替换长度大于函数 2.宏执行速度更快，函数调用返回存在额外开销 3.副作用的宏相比函数更为复杂，宏不便于调试 4.宏需进行多次参数求值，函数只求一次 5.宏可用于任何参数类型，函数有类型检查
- 条件编译：#if #endif

## 编译链接

- 预处理器处理(test.i):文本处理(gcc-E test.c>test.i):1.#include 的处理 2.删注释 3.#define 的替换
- 编译(test.s):gcc -S test.c:翻译为汇编语言(语法、词法、语义分析、符号汇总)
- 汇编(test.o):形成符号表，翻译为机器语言
- 链接(test.exe):合并段表、符号表的合并和符号表的重定义
